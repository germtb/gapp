package codegen

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// RpcSpec defines an RPC to preload with optional parameter mappings.
type RpcSpec struct {
	Method string
	Params map[string]string
}

// RoutePreload defines preload configuration for a route pattern.
type RoutePreload struct {
	Path string
	Rpcs []RpcSpec
}

var (
	pathRe   = regexp.MustCompile(`path:\s*"([^"]+)"`)
	methodRe = regexp.MustCompile(`method:\s*"([^"]+)"`)
	paramsRe = regexp.MustCompile(`params:\s*\{([^}]+)\}`)
	paramKV  = regexp.MustCompile(`"([^"]+)":\s*"([^"]+)"`)
)

// ParseRouteFile extracts the route path and RPC declarations from a TypeScript route file.
// It looks for the pattern:
//
//	export const xxxRoute = {
//	  path: "/...",
//	  factory: () => ({
//	    rpcs: [
//	      { method: "MethodName" },
//	      { method: "Other", params: { "id": "userId" } },
//	    ],
//	  }),
//	};
func ParseRouteFile(filePath string) (*RoutePreload, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}
	content := string(data)

	// Extract path
	pathMatch := pathRe.FindStringSubmatch(content)
	if pathMatch == nil {
		return nil, nil // No route definition found
	}
	routePath := pathMatch[1]

	// Find the rpcs array region
	rpcsIdx := strings.Index(content, "rpcs:")
	if rpcsIdx == -1 {
		return nil, nil // No rpcs declaration
	}

	// Extract the rpcs array content (from rpcs: [ ... ])
	rpcsContent := content[rpcsIdx:]
	bracketStart := strings.Index(rpcsContent, "[")
	if bracketStart == -1 {
		return nil, nil
	}

	// Find matching bracket
	depth := 0
	bracketEnd := -1
	for i := bracketStart; i < len(rpcsContent); i++ {
		switch rpcsContent[i] {
		case '[':
			depth++
		case ']':
			depth--
			if depth == 0 {
				bracketEnd = i
			}
		}
		if bracketEnd != -1 {
			break
		}
	}
	if bracketEnd == -1 {
		return nil, nil
	}

	arrayContent := rpcsContent[bracketStart : bracketEnd+1]

	// Extract each { method: "...", params?: { ... } } object
	var rpcs []RpcSpec

	// Find top-level objects in the array (depth-aware brace matching)
	objStart := -1
	depth = 0
	for i := 0; i < len(arrayContent); i++ {
		if arrayContent[i] == '{' {
			if depth == 0 {
				objStart = i
			}
			depth++
		}
		if arrayContent[i] == '}' {
			depth--
			if depth == 0 && objStart != -1 {
				objContent := arrayContent[objStart : i+1]
				objStart = -1

				m := methodRe.FindStringSubmatch(objContent)
				if m == nil {
					continue
				}

				rpc := RpcSpec{Method: m[1]}

				// Check for params
				p := paramsRe.FindStringSubmatch(objContent)
				if p != nil {
					rpc.Params = make(map[string]string)
					kvs := paramKV.FindAllStringSubmatch(p[1], -1)
					for _, kv := range kvs {
						rpc.Params[kv[1]] = kv[2]
					}
				}

				rpcs = append(rpcs, rpc)
			}
		}
	}

	if len(rpcs) == 0 {
		return nil, nil
	}

	return &RoutePreload{Path: routePath, Rpcs: rpcs}, nil
}

// ScanRoutes scans a directory for route files and extracts preload configs.
func ScanRoutes(routesDir string) ([]RoutePreload, error) {
	entries, err := os.ReadDir(routesDir)
	if err != nil {
		return nil, fmt.Errorf("reading routes directory: %w", err)
	}

	var routes []RoutePreload
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if !strings.HasSuffix(name, ".ts") && !strings.HasSuffix(name, ".tsx") {
			continue
		}

		route, err := ParseRouteFile(filepath.Join(routesDir, name))
		if err != nil {
			return nil, fmt.Errorf("parsing %s: %w", name, err)
		}
		if route != nil {
			routes = append(routes, *route)
		}
	}

	return routes, nil
}

// GeneratePreloadGo generates Go source code for the preload route config.
// It imports gapp's RouteSpec/RpcSpec types directly so the generated var
// is compatible with gapp.NewPreloadEngine.
func GeneratePreloadGo(routes []RoutePreload, packageName string) string {
	methodSet := make(map[string]bool)
	for _, r := range routes {
		for _, rpc := range r.Rpcs {
			methodSet[rpc.Method] = true
		}
	}

	var sortedMethods []string
	for m := range methodSet {
		sortedMethods = append(sortedMethods, m)
	}
	sort.Strings(sortedMethods)

	var b strings.Builder
	b.WriteString("// Code generated by gapp codegen. DO NOT EDIT.\n\n")
	b.WriteString("package " + packageName + "\n\n")

	b.WriteString("import gapp \"github.com/germtb/gapp\"\n\n")

	b.WriteString("// RoutePreloads contains all route preload configurations\n")
	b.WriteString("var RoutePreloads = []gapp.RouteSpec{\n")

	for _, route := range routes {
		if len(route.Rpcs) == 0 {
			continue
		}
		b.WriteString("\t{\n")
		b.WriteString(fmt.Sprintf("\t\tPattern: %q,\n", route.Path))
		b.WriteString("\t\tRpcs: []gapp.RpcSpec{\n")
		for _, rpc := range route.Rpcs {
			params := "nil"
			if len(rpc.Params) > 0 {
				var kvs []string
				for k, v := range rpc.Params {
					kvs = append(kvs, fmt.Sprintf("%q: %q", k, v))
				}
				sort.Strings(kvs)
				params = "map[string]string{" + strings.Join(kvs, ", ") + "}"
			}
			b.WriteString(fmt.Sprintf("\t\t\t{Method: %q, Params: %s},\n", rpc.Method, params))
		}
		b.WriteString("\t\t},\n")
		b.WriteString("\t},\n")
	}

	b.WriteString("}\n\n")

	b.WriteString("// PreloadMethods contains all unique RPC methods that need preload handlers\n")
	b.WriteString("var PreloadMethods = []string{\n")
	for _, m := range sortedMethods {
		b.WriteString(fmt.Sprintf("\t%q,\n", m))
	}
	b.WriteString("}\n")

	return b.String()
}
