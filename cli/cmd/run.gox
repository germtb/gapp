package cmd

import (
	"bufio"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/fsnotify/fsnotify"
	"github.com/germtb/goli"
	"github.com/germtb/gox"
)

type LogPaneProps struct {
	Title string
	Lines goli.Accessor[[]string]
}

func LogPane(props LogPaneProps) gox.VNode {
	lines := props.Lines()

	return <box direction="column" grow={1} border="rounded" overflow="hidden">
		<box direction="row">
			<text bold={true}>{" " + props.Title + " "}</text>
		</box>
		{gox.Map(lines, func(line string) gox.VNode {
			return <ansi>{line}</ansi>
		})}
	</box>
}

type RunAppProps struct {
	ServerLines goli.Accessor[[]string]
	ClientLines goli.Accessor[[]string]
}

func RunApp(props RunAppProps) gox.VNode {
	return <box direction="column" grow={1}>
		<LogPane Title="server" Lines={props.ServerLines} />
		<LogPane Title="client" Lines={props.ClientLines} />
		<text dim={true}>{" Ctrl+C to stop"}</text>
	</box>
}

func killProcessGroup(cmd *exec.Cmd) {
	if cmd == nil || cmd.Process == nil {
		return
	}
	pgid, err := syscall.Getpgid(cmd.Process.Pid)
	if err == nil {
		syscall.Kill(-pgid, syscall.SIGTERM)
	}
}

func RunRun(args []string) error {
	// Parse optional project directory from args
	projectDir := "."
	for _, arg := range args {
		if !strings.HasPrefix(arg, "-") {
			projectDir = arg
			break
		}
	}

	serverDir := filepath.Join(projectDir, "server")
	clientDir := filepath.Join(projectDir, "client")

	if _, err := os.Stat(filepath.Join(serverDir, "main.go")); os.IsNotExist(err) {
		goli.Print(<box direction="row">
			<text color="red">{"âœ—"}</text>
			<text>{" Not a gap project (server/main.go not found in " + projectDir + ")"}</text>
		</box>)
		return err
	}

	serverLines, setServerLines := goli.CreateSignal([]string{})
	clientLines, setClientLines := goli.CreateSignal([]string{})

	var serverCmd *exec.Cmd
	var clientCmd *exec.Cmd
	var mu sync.Mutex
	var watcher *fsnotify.Watcher

	var cleanupOnce sync.Once
	cleanup := func() {
		cleanupOnce.Do(func() {
			mu.Lock()
			defer mu.Unlock()
			killProcessGroup(serverCmd)
			killProcessGroup(clientCmd)
			if watcher != nil {
				watcher.Close()
			}
		})
	}

	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGTERM)
	go func() {
		<-sigCh
		cleanup()
		os.Exit(0)
	}()

	startSubprocess := func(name string, cmdArgs []string, dir string, setter goli.Setter[[]string], getter goli.Accessor[[]string]) *exec.Cmd {
		cmd := exec.Command(name, cmdArgs...)
		cmd.Dir = dir
		cmd.Env = append(os.Environ(), "FORCE_COLOR=1")
		cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}

		r, w, err := os.Pipe()
		if err != nil {
			setter([]string{"Failed to create pipe: " + err.Error()})
			return nil
		}
		cmd.Stdout = w
		cmd.Stderr = w

		if err := cmd.Start(); err != nil {
			setter([]string{"Failed to start: " + err.Error()})
			r.Close()
			w.Close()
			return nil
		}
		w.Close()

		setter([]string{"Starting " + name + " ..."})

		go func() {
			scanner := bufio.NewScanner(r)
			scanner.Buffer(make([]byte, 64*1024), 64*1024)
			for scanner.Scan() {
				line := scanner.Text()
				goli.SetWith(setter, func(prev []string) []string {
					next := append(prev, line)
					if len(next) > 500 {
						next = next[len(next)-500:]
					}
					return next
				}, getter)
			}
			r.Close()
		}()

		go func() {
			cmd.Wait()
			time.Sleep(50 * time.Millisecond)
			goli.SetWith(setter, func(prev []string) []string {
				return append(prev, "Process exited")
			}, getter)
		}()

		return cmd
	}

	startServer := func() {
		mu.Lock()
		defer mu.Unlock()
		serverCmd = startSubprocess("go", []string{"run", "."}, serverDir, setServerLines, serverLines)
	}

	restartServer := func() {
		mu.Lock()
		killProcessGroup(serverCmd)
		mu.Unlock()

		// Give the old process a moment to exit
		time.Sleep(100 * time.Millisecond)

		goli.SetWith(setServerLines, func(prev []string) []string {
			return append(prev, "File change detected, restarting...")
		}, serverLines)

		startServer()
	}

	goli.Run(func() gox.VNode {
		return <RunApp ServerLines={serverLines} ClientLines={clientLines} />
	}, goli.RunOptions{
		OnMount: func(app *goli.App) {
			go func() {
				ticker := time.NewTicker(50 * time.Millisecond)
				defer ticker.Stop()
				for range ticker.C {
					app.Rerender()
				}
			}()

			startServer()
			clientCmd = startSubprocess("./node_modules/.bin/vite", nil, clientDir, setClientLines, clientLines)

			// Watch for .go file changes and restart server
			var watchErr error
			watcher, watchErr = WatchGoFiles(serverDir, 300*time.Millisecond, restartServer)
			if watchErr != nil {
				goli.SetWith(setServerLines, func(prev []string) []string {
					return append(prev, "Warning: file watcher failed: "+watchErr.Error())
				}, serverLines)
			}
		},
		OnUnmount: func() {
			signal.Stop(sigCh)
			cleanup()
		},
	})

	return nil
}
